## 设计原则
[单一职责原则](单一职责原则)
[最少知识原则](最少知识原则)
[开放-封闭原则](开放-封闭原则)
[接口和面向接口原则](接口和面向接口原则)

### 单一职责原则
#### 定义
**单一职责原则** 的职责被定义为“引起变化的原因”，如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大，此时一个职责的变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是地内聚和脆弱的设计

#### 原则
一个方法只做一件事情

#### 何时分离职责
- 如果随着需求的变化，有两个职责总是同时变化，那就不必分离它们
- 职责的变化轴线仅当它们确实会发生变化时才具有意义，即使两个职责已经被耦合在一起，如果未发生改变的征兆，并没有必要主动分离它们，在代码需要重构的时候在进行分离也不迟
- 在**方便性**与**稳定性**之间要有一些取舍，具体是选择方便性还是稳定性，并没有标准答案

#### 单一职责原则的优缺点
- 优点：降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试
- 缺点：增加编写代码的复杂度，增大了这些对象之间相互联系的难度

### 最少知识原则
#### 定义
一个软件实体应当尽可能少地与其他实体发生相互作用

如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用

#### 外观模式
**外观模式**是一个典型的最少知识原则的例子

- 对客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现
- 大多数客户都可以通过请求外观接口来达到访问子系统的目的
- 但在请求外观模式的程序中，请求外观并不是强制的。如果外观不能满足个性化需求，那么也可以选择越过外观来直接访问子系统

#### 封装
封装在很大程度上表达的是**数据的隐藏**。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口 API 供外界访问

把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小

### 开放-封闭原则
#### 定义
当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码

#### 应用
对于一段程序，变化的部分需要开放，而稳定的部分需要封闭，我们要找出稳定不变的部分和容易变化的部分并隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分

下面介绍几种利于编写遵守**开放-封闭原则**的方式：
- 对象的多态性
- 放置 Hook，用来控制变化
- 使用回调函数

#### 相对性
实际上，让程序完全遵循**开放-封闭**是不容易做到的，总会存在一些无法对其封闭的变化，我们能做到的有两点：

- 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化
- 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方

### 接口和面向接口编程
一般的接口有三种含义：
1. 一个库或者模块暴露用来通信的手段，（可以隐藏软件系统内部的工作细节）
2. 一些语言提供的关键字，比如 JAVA 的 interface
3. 对象能响应的请求的集合

面向接口编程主要针对的是 2 和 3

#### 面向对象中的 interface/抽象类
interface/抽象类 主要有两个作用：
1. 向上转型
2. 建立一些契约

**面向接口编程** 即针对超类型中的“契约方法”来编写程序，这些契约行为暴露了一个类或者对象能够做什么，但是不关心具体如何去做。这样可以产生可靠性高的程序，也可以极大地减少子系统实现之间的相互依赖关系

### JavaScript 中的面向接口编程
在动态类型语言中，对象的多态性是与生俱来的，所以，只需要**契约关系**能建立起来就行，不必借助超类型的帮助

比如：一个对象如果有 push 和 pop 方法，并提供了正确的实现，它就能被当作栈来使用







