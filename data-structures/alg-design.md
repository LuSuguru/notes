## 算法设计技巧

### 贪婪算法
前面在图论中已经聊到了三种贪婪算法：Dijkstra 算法，Prim 算法和 Kruskal 算法

- **贪婪算法**分阶段地工作，在每一个阶段，可以认为所作决定是好的，而不考虑将来的后果，相当于选择的是某个局部的最优
- 当算法终止时，我们希望局部最优就是全局最优。如果是这样的话，那么算法就是正确的；否则，算法得到的是一个 **次最优解**

#### 贪婪算法的例子

##### 一个简单的调度问题
**问题**：今有作业 j1,j2,...,jN，已知对应的运行时间为 t1,t2,...,tN,而处理器只有一个。为了把作业平均完成的时间最小化？（我们将假设使用 **非预设调度**：一旦开始一个作业，就必须把该作业运行到完成）

<img1/>

如下图，平均完成时间为 25
<img2/>

如下图，平均完成时间未 17.75
<img3/>

第一个作业以 t1 时间完成
第二个作业以 t1 + t2 来完成
第三个作业以 t1 + t2 + t3 来完成
综上，总的代价 
C = (N ∑ 1)(N - K +1) * jk * tk => C = (N + 1)(N ∑ 1) * jk * tk - (N ∑ 1)k * jk * tk

只有第二个求和影响到总开销，因此，为了使 C 最小，我们要保证第 k 次 jk * tk 最小，这就是 **贪婪算法** 中的局部最优解，因此，调度采用单调递减是最优解

*操作系统调度程序一般把高优先级赋予那些更短的作业*

另外，我们把 **单处理器** 切换到 **多处理器** 情况下，如下图
<img4/>
<img5/>

解决多处理器情形的算法是按顺序开始作业，处理器之间轮换分配，这存在多个最优解的可能，只要保证 J(ip) 到 J(i(p+1)) 的每一个作业放到不同的处理器上

如下图，是第二个最优解
<img6/>

##### Huffman 编码，文件压缩
**问题**：设我们有一个文件，它只包含字符 a,e,i,s,t,加上一些空格和 newline(换行)。进一步设该文件分别有10个a、15个e、12个i、3个s、4个t、13个空格以及一个 newline，如下图：

<img7/>

如果文件非常大，这种传输是非常消耗资源的

设想，由于每个字符的出现频率是不相同的，如 newline 和 e，我们是否可以根据这个频率设置字符的代码长度，保证经常出现的字符代码长，反之则代码短

我们可以用二叉树表示字母的二进制代码，左代表0，右代表1，如下图：

<img8/>

另外，该树还是一颗 **满树**：所有的节点或者是树叶，或者有两个儿子

如果一个字符放在非树叶节点上，那么可能无法保证字符的唯一性。因此，我们要提高那些频率高的字符的树叶深度，构造一颗总价值最小的满二叉树，如下图：

<img9/>

##### Huffman 算法：
- 每个字符当做一个树，该算法对这些树组成的森林进行
- 一棵树的权等于它的树叶的评率的和
- 任意选取最小权的两棵树 T1 和 T2，并任意形成以 T1 和 T2 为子树的新树
- 将这样的过程进行 C - 1次，最后得到一颗树，该树就是总价值最小的满二叉树

该算法是一个 **贪婪算法**，在每一个阶段我们都进行一次最小权的树的合并而且没有进行全局的考虑

具体的实现我们可以用 **优先队列** 表示这个森林，由于对元素个数不超过 C 的优先队列将进行一次 BuildHeap、2C - 2 次 DeleteMin 和 C - 2 次 Insert，因此运行时间为 O(C logC)

##### 近似装箱问题
**问题**：设给定 N 项物品，大小为 S1,S2,...,Sn,所有的大小满足 0 < Si <= 1。把这些物品装到最小数目的箱子中去

该问题有两个版本：
1. 联机：必须将每一件物品放入一个箱子之后才处理下一个物品
2. 脱机：需要等到所有的输入数据全被读入之后才进行

**联机**


如果存在 N 个点，那么就存在 N(N - 1)/2 对点间的距离，我们可以穷举所有的距离，找到最短的距离

我们可以采用 **分治算法**，假设这些点已按 x 坐标排过序，那么我们就可以画一条想象的垂线，把点集分成两半：Pl 和 Pr，最近的一对点或者都在 Pl 中，或者都在 Pr 中，或者一个在 Pl 中而另外一个在 Pr 中，我们分别把这些距离叫做 dl,dr,dc

令 s = min(dl,dr)，如果 dc 对 s 有改进，那么我们只需要计算 dc，如果 dc 是这样的距离，则定义 dc 的两个点必然在分割线的 s 距离之内；我们将把整个区域叫做一条 **带**

有两种方法计算 dc，穷举 位于 **带** 中的点

```c++
for (let i = 0; i < numPointsInstrip; i++) {
  for (let j = i + 1; j < numPointsInstrip; j++) {
    if (dist(pi, pj) < s) {
      s = dist(pi, pj)
    }
  }
}
```

我们可以优化这个算法，设带中的点按照它们的 y坐标 排过序。因此，如果 Pi 和 pj 的 y 坐标相差大于 s ，那么我们跳过这个点直接处理 pi+1

```c++
for (let i = 0; i < numPointsInstrip; i++) {
  for (let j = i + 1; j < numPointsInstrip; j++) {
    // 通过 y 坐标筛选
    if (Math.abs(getYdist(pi) - getYdist(pj)) > s) {
      break
    } else if (dist(pi, pj) < s) {
      s = dist(pi, pj)
    }
  }
}
```

##### 选择问题
**问题**：找出 N 个元素的表 S 中的第 k 个最小的元素









