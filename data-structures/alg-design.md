## 算法设计技巧

### 贪婪算法
前面在图论中已经聊到了三种贪婪算法：Dijkstra 算法，Prim 算法和 Kruskal 算法

- **贪婪算法**分阶段地工作，在每一个阶段，可以认为所作决定是好的，而不考虑将来的后果，相当于选择的是某个局部的最优
- 当算法终止时，我们希望局部最优就是全局最优。如果是这样的话，那么算法就是正确的；否则，算法得到的是一个 **次最优解**

#### 贪婪算法的例子

##### 一个简单的调度问题
**问题**：今有作业 j1,j2,...,jN，已知对应的运行时间为 t1,t2,...,tN,而处理器只有一个。为了把作业平均完成的时间最小化？（我们将假设使用 **非预设调度**：一旦开始一个作业，就必须把该作业运行到完成）

<img1/>

如下图，平均完成时间为 25
<img2/>

如下图，平均完成时间未 17.75
<img3/>

第一个作业以 t1 时间完成
第二个作业以 t1 + t2 来完成
第三个作业以 t1 + t2 + t3 来完成
综上，总的代价 
C = (N ∑ 1)(N - K +1) * jk * tk => C = (N + 1)(N ∑ 1) * jk * tk - (N ∑ 1)k * jk * tk

只有第二个求和影响到总开销，因此，为了使 C 最小，我们要保证第 k 次 jk * tk 最小，这就是 **贪婪算法** 中的局部最优解，因此，调度采用单调递减是最优解

*操作系统调度程序一般把高优先级赋予那些更短的作业*

另外，我们把 **单处理器** 切换到 **多处理器** 情况下，如下图
<img4/>
<img5/>

解决多处理器情形的算法是按顺序开始作业，处理器之间轮换分配，这存在多个最优解的可能，只要保证 J(ip) 到 J(i(p+1)) 的每一个作业放到不同的处理器上

如下图，是第二个最优解
<img6/>

##### Huffman 编码，文件压缩
**问题**：设我们有一个文件，它只包含字符 a,e,i,s,t,加上一些空格和 newline(换行)。进一步设该文件分别有10个a、15个e、12个i、3个s、4个t、13个空格以及一个 newline，如下图：

<img7/>

如果文件非常大，这种传输是非常消耗资源的

设想，由于每个字符的出现频率是不相同的，如 newline 和 e，我们是否可以根据这个频率设置字符的代码长度，保证经常出现的字符代码长，反之则代码短

我们可以用二叉树表示字母的二进制代码，左代表0，右代表1，如下图：

<img8/>

另外，该树还是一颗 **满树**：所有的节点或者是树叶，或者有两个儿子

如果一个字符放在非树叶节点上，那么可能无法保证字符的唯一性。因此，我们要提高那些频率高的字符的树叶深度，构造一颗总价值最小的满二叉树，如下图：

<img9/>

##### Huffman 算法：
- 每个字符当做一个树，该算法对这些树组成的森林进行
- 一棵树的权等于它的树叶的评率的和
- 任意选取最小权的两棵树 T1 和 T2，并任意形成以 T1 和 T2 为子树的新树
- 将这样的过程进行 C - 1次，最后得到一颗树，该树就是总价值最小的满二叉树

该算法是一个 **贪婪算法**，在每一个阶段我们都进行一次最小权的树的合并而且没有进行全局的考虑

具体的实现我们可以用 **优先队列** 表示这个森林，由于对元素个数不超过 C 的优先队列将进行一次 BuildHeap、2C - 2 次 DeleteMin 和 C - 2 次 Insert，因此运行时间为 O(C logC)

#### 近似装箱问题
**问题**：设给定 N 项物品，大小为 S1,S2,...,Sn,所有的大小满足 0 < Si <= 1。把这些物品装到最小数目的箱子中去

该问题有两个版本：
1. 联机：必须将每一件物品放入一个箱子之后才处理下一个物品
2. 脱机：需要等到所有的输入数据全被读入之后才进行

**联机**

在 **联机** 情况下，不存在最优算法

对于 **联机** 情况，我们有三种 **贪婪算法** 可以解决：

1. 下项适合算法：当处理任何一项物品时，检查看它是否还能装进刚刚装进物品的同一个箱子中去。如果能够装进去，那么就把它放入该箱中；否则，就开辟一个新的箱子
2. 首次适合算法：依次扫描这些箱子并把新的一项物品放入足够盛下它的第一个箱子中。因此，只有当先前放置物品的结果已经没有再容下当前物品余地的时候，才会开辟一个新箱子
3. 最佳适合算法：该法不是把一项新物品放入所发现的第一个能够容纳它的箱子，而是放到所有箱子中能够容纳它的最满的箱子中

**脱机**

可找到最优解

对于 **脱机** 情况下，由于已经知晓了全部物品，我们可以按照递减的顺序排序物品，然后在采用 **首次适合递减算法** 或 **最佳适合递减算法**

### 分治算法

**分治算法** 由两部分组成：
1. **分**：递归解决较小的问题（基础情况除外）（至少两个递归调用）
2. **治**：从子问题的解构构建原问题的解

#### 分治算法的运行时间
对于分治算法，我们课程将每个问题分成若干个子问题，并使用 O(N^K)附加工作

T(N) = aT(N/b) + O(N^K)的时间复杂度为
- O(N^logb a)；若 a > b^k
- O(N^k logN)；若 a = b^k
- O(N^k)；     若 a < b^k

#### 分支算法的例子

##### 最近点问题
**问题**：平面上的点集合P，找出一对最近的点，有可能两个点位于相同的位置，在这种情况下两个就是最近的，它们的距离为 0

如果存在 N 个点，那么就存在 N(N - 1)/2 对点间的距离，我们可以穷举所有的距离，找到最短的距离

我们可以采用 **分治算法**，假设这些点已按 x 坐标排过序，那么我们就可以画一条想象的垂线，把点集分成两半：Pl 和 Pr，最近的一对点或者都在 Pl 中，或者都在 Pr 中，或者一个在 Pl 中而另外一个在 Pr 中，我们分别把这些距离叫做 dl,dr,dc

<img10/>

令 s = min(dl,dr)，如果 dc 对 s 有改进，那么我们只需要计算 dc，如果 dc 是这样的距离，则定义 dc 的两个点必然在分割线的 s 距离之内；我们将把整个区域叫做一条 **带**

<img11/>

有两种方法计算 dc，穷举 位于 **带** 中的点

```c++
for (let i = 0; i < numPointsInstrip; i++) {
  for (let j = i + 1; j < numPointsInstrip; j++) {
    if (dist(pi, pj) < s) {
      s = dist(pi, pj)
    }
  }
}
```

我们可以优化这个算法，设带中的点按照它们的 y坐标 排过序。因此，如果 Pi 和 pj 的 y 坐标相差大于 s ，那么我们跳过这个点直接处理 pi+1

```c++
for (let i = 0; i < numPointsInstrip; i++) {
  for (let j = i + 1; j < numPointsInstrip; j++) {
    // 通过 y 坐标筛选
    if (Math.abs(getYdist(pi) - getYdist(pj)) > s) {
      break
    } else if (dist(pi, pj) < s) {
      s = dist(pi, pj)
    }
  }
}
```

##### 选择问题
**问题**：找出 N 个元素的表 S 中的第 k 个最小的元素

前面的快速选择就是一个 **分治算法** 的例子，这个算法最坏的时间复杂度为 O(N^2)。如果枢纽元选择的过大，因此，枢纽元的选择就变得相当重要，这里提供一种较好的枢纽元选择算法：

1. 把 N 个元素分成 [N / 5] 组，5 个元素一组，忽略（最多 4 个）剩余的元素
2. 找出每组的中项，得到 [N / 5] 个中项的表 M
3. 求出 M 的中项，将其作为枢纽元 v 返回

##### 整数相乘
**问题**：如果要将两个 N 位数 X 和 Y 相乘。X 的每一位数字都要与 Y 的每一位数字相乘，需要 O(N^2) 次操作

如果 X = 61438512 而 Y = 94736407，那么 XY = 5820 464 730 934 047，让我们把 X 和 Y 拆分为两半，分别由最高几位和最低几位数字组成。此时，Xl = 6143，Xr = 8251，Yl = 9473，Yr = 6407。由于得到：
 XY = XlYl * 10^8 + (XlYr + XrYl) * 10^4 + XrYr

通过分治，得到递归： T(N) = 4T / (N / 2) + O(N)

从定理得知 T(N) = O(N^2)，这跟原来一样，因此还需要优化：
XlYr + XrYl = (Xl - Xr)(Yr - Yl) + XlYl + XrYr
 
此时，T(N) = 3T( N / 2 ) + O(N)，从而 T(N) = O(N^1.58),

为了完成这个算法，我们必须要有一个基准情况，该情况无须递归而解决

### 动态规划
某些 **递归算法** 存在着重复性的工作，最终导致低效的算法，此时我们可以提供一种方式，将 **递归算法** 重新写成 **非递归算法**，让后者把那些子问题的答案系统地记录在一个表内。利用这种方式叫做 **动态规划**

#### 动态规划的例子

##### 用一个表代替递归

```c++
int
fib(int N) {
  if( N <= 1) {
    return 1
  } else {
    return fib(N - 1) + fib(N - 2)
  }
}
```

如上述代码，为了计算 Fn，存在一个对 Fn-1 和 Fn-2的调用，由于 Fn-1 递归地对 Fn-2 和 Fn-3 进行调用，导致 Fn-2 进行了2次，类推，Fn-3 被计算了3次，Fn-4 计算了5次，最终导致算法非常低效

如果能够保留一个预先算出的值而对已解过的子问题不再进行递归调用，那么就可以避免这种低效，如下是改进后的代码：

```c++
fibonacci(int N) {
  int i, last, nextToLast,answer

  if(N <= 1) {
    return 1
  }

  last = nextTolast = 1

  for(i = 2; i <= N; i++) {
    answer = last + nextToLast
    nextToLast = last
    last = answer
  }

  return answer
}
```

第二个例子，代码如下，这个例子中，每一次 sum 都将前面算过 的 sum 又累加了一次，这种增长是指数级的
```c++
eval(int N) {
  int i
  double sum

  if(N == 0) {
    retutn 1.0
  } else {
    sum = 0.0
    for(i = 0; i < N; i++) {
      sum += eval(i);
      return 2.0 * sum / n + n
    }
  }
}
```

同样，我们可以通过 **动态规划** 来优化它，它的运行时间为 O(N)

```c++
eval(int N) {
  int i
  double sum = 0.0
  double last = 1.0

  for(i = 1; i <= N; i++) {
    sum = 2.0 * last / i + i
    last = sum + last
  }
}
```

  



