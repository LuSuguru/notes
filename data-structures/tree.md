对于大量的输入数据，链表的线性访问时间太慢，此时，可以使用树的数据结构

### 树（tree）
#### 定义
- 树（tree）：一些节点的集合
- 根（root）
- 子树：一棵完整的但不包含根节点的树
- 边（edge）：节点相互连接的单位
- 子节点（child）：
- 父节点（parent）：
- 树叶（leaf）：没有子节点的节点
- 兄弟节点（sibling）：具有相同父节点的节点
- 路径（path）：从 n1 到 nk 的路径为 n1，n2,...,nk(结束节点)的一个序列，并且上一个节点是下一个节点的父节点
- 路径的长（length）：该路径上的边的条数，每个节点到自身的长度为0，在一棵树中从根节点到每个节点恰好存在一条路径
- 深度（depth）：对任意节点 ni，从根节点到 ni 的唯一路径的长。因此，根节点的深度为0
- 高（height）：对任意节点 ni，从 ni 到一片子树叶最长路径的长 。因此，所有子树叶的高都是0，一棵树的高等于它的根的高
- 祖先（ancestor）和后裔（descendant）：如果存在从 n1 到 n2 的一条路径，那么 n1 是 n2 的一位祖先，而 n2 是 n1 的一个后裔
- 真祖先（proper ancestor）和真后裔（proper descendant）：满足上条且 n1 != n2

#### 实现

1. 每一个节点除了数据外还要有一些指针，使得该节点的每一个子节点都有一个指针指向它
2. 将每个节点记录在链表中，父节点记录链表头，即第一个子节点
3. 每个节点都有指针指向兄弟节点（sibling）

#### 树的应用
- 操作系统中的文件系统
- react 中的 fiber 结构

#### 树的遍历
- 先序遍历：对节点的处理工作是在它的诸儿子节点被处理之前进行的
- 后序遍历：在一个节点处的工作是在它的诸儿子节点被处理后进行的
- 中序遍历：先处理左子树，在处理中节点，最后处理右子树

### 二叉树（binary tree）
- 一棵树，且每个节点都不能有多余两个子节点
- 二叉树的一个性质是平均二叉树的深度要比 N 小得多，**查找二叉树**深度的平均值是 O(log N)



