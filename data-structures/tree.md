对于大量的输入数据，链表的线性访问时间太慢，此时，可以使用树的数据结构

### 树（tree）
#### 定义
- 树（tree）：一些节点的集合
- 根（root）
- 子树：一棵完整的但不包含根节点的树
- 边（edge）：节点相互连接的单位
- 子节点（child）：
- 父节点（parent）：
- 树叶（leaf）：没有子节点的节点
- 兄弟节点（sibling）：具有相同父节点的节点
- 路径（path）：从 n1 到 nk 的路径为 n1，n2,...,nk(结束节点)的一个序列，并且上一个节点是下一个节点的父节点
- 路径的长（length）：该路径上的边的条数，每个节点到自身的长度为0，在一棵树中从根节点到每个节点恰好存在一条路径
- 深度（depth）：对任意节点 ni，从根节点到 ni 的唯一路径的长。因此，根节点的深度为0
- 高（height）：对任意节点 ni，从 ni 到一片子树叶最长路径的长 。因此，所有子树叶的高都是0，一棵树的高等于它的根的高
- 祖先（ancestor）和后裔（descendant）：如果存在从 n1 到 n2 的一条路径，那么 n1 是 n2 的一位祖先，而 n2 是 n1 的一个后裔
- 真祖先（proper ancestor）和真后裔（proper descendant）：满足上条且 n1 != n2

#### 树的实现

1. 每一个节点除了数据外还要有一些指针，使得该节点的每一个子节点都有一个指针指向它
2. 将每个节点记录在链表中，父节点记录链表头，即第一个子节点
3. 每个节点都有指针指向兄弟节点（sibling）

#### 树的应用
- 操作系统中的文件系统
- react 中的 fiber 结构

#### 树的遍历
- 先序遍历：对节点的处理工作是在它的诸儿子节点被处理之前进行的
- 后序遍历：在一个节点处的工作是在它的诸儿子节点被处理后进行的
- 中序遍历：先处理左子树，在处理中节点，最后处理右子树

### 二叉树（binary tree）
- 一棵树，且每个节点都不能有多余两个子节点
- 二叉树的一个性质是平均二叉树的深度要比 N 小得多，**查找二叉树**深度的平均值是 O(log N)

#### 二叉树的实现
1. 因为一棵二叉树最多有两个子节点，所以我们可以用指针直接指向它们
2. 一个节点包含内容信息和左右子树的指针

#### 二叉树的应用
- 编译器的设计，如表达式树
  1. 表达式树的树叶是**操作数**，比如常量和变量
  2. 其他的节点为**操作符**
  3. 通过不同的遍历方式，我们可以运行表达式

### 二叉查找树
- 在二叉树的基础上，保证对于树中的每个节点 X，它的左子树中所有关键字值小于 X 的关键字值，而它的右子树中所有关键字值大于X的关键字值
- 该树所有的元素都可以用某种统一的方式排序
- 由于树的递归定义，大多数二叉查找树采用递归实现，因为二叉查找树的平均深度是 0(log N)，一般不必担心栈空间被用尽


### 二叉查找树的操作
- Find
  1. 在树 T 中查找具有关键字 X 的节点的指针，先判断 T 是否为 null
  2. 不为 null 的话就判断 x 与 当前 T 的关键字的关系，递归调用树 T 的左子树或者右子树直到找到节点为止

- FindMin：从根节点一直向左，终止点就是最小的元素
- FindMax：从根节点一直向右，终止点是最大的元素
- Insert：为了将 X 插入到树 T 中，可以像用 Find 那样沿着树查找，如果找到 X，则什么也不用做。否则，将 X 插入到遍历的路径上的最后一个点上，重复元的插入可以通过在节点记录中保留一个附加域以指示发生的频率来处理
- Delete：
  1. 如果节点是一片树叶，那么它可以直接被立即删除。如果节点有一个子节点，则该节点可以在其父节点调整指针绕过该节点后被删除
  2. 若删除的节点具有两个子节点，用其右子树的最小的数据代替该节点的数据并递归地删除那个节点，因为右子树中最小的节点不可能有左边的子节点。但是它的效率不高，因为一次删除要遍历两次
  3. 如果删除的次数不多，可以使用**懒惰删除**，当一个元素要被删除时，它仍留在树中，而是只做了个被删除的记号。这种做法特别是在有重复关键字时很流行，因为此时记录出现频率数的域可以减1

所有操作的时间复杂度都为O(d)，d与树的深度有关，而二叉树平均深度为O(logN)

由于二叉查找树的时间复杂度与深度强关联，在连续插入时，很可能会加大树的深度，导致花费很多的运算时间。为了优化这种情况，会在二叉查找树中添加一个平衡条件：**任何节点的深度均不得过深**




