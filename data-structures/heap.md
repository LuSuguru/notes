### 优先队列（堆）

优先队列是允许至少下列两种操作的数据结构：
- Insert：插入，等价于 Enqueue(入队)
- DeleteMin：找出、返回和删除优先队列中最小的元素，等价于出队(Dequeue)

### 优先队列几种简单的实现
##### 使用链表（有两种）
1. 在表头以 O(1) 执行插入操作，并遍历该链表以删除最小元，这需要 O(N) 时间
2.  始终让表保持排序状态，这使得插入代价高昂（O(N)）而 DeleteMin 花费低廉 (O(1))

##### 使用二叉查找树
它对两种操作的平均运行时间都是 O(log N)
基于 **二叉查找树** 的特性，插入是随机的，但删除则不是，会反复除去左子树中的节点

### 二叉堆（堆）
一般把二叉堆称为堆，它有两个性质，即结构性和堆序性

##### 结构性
堆是一棵被完全填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填入。这样的树称为 **完全二叉树**，它的高是 [Log N]

我们可以使用 **数组** 实现 **完全二叉树**

**对于数组中任一位置 i 上的元素，其左儿子在位置 2i 上，右儿子在左二子后的单元 (2i + 1)中，它的父亲则在位置 [i / 2]上**

##### 堆序性
使操作被快速执行的性质是 **堆序性**

- 由于我们需要快速地找出最小元，因此最小元应该在根上
- 如果我们考虑任意子树也应该是一个堆，那么任意节点就应该小于它的所有后裔

根据堆序性，最小元总可以在根处找到

### 堆的基本操作
##### Insert(插入) O(log N)

新元素插入时通过**上滤**找出正确的位置

*上滤*：
- 为将一个元素 X 插入到堆中，我们在下一个空闲位置创建一个空穴
- 如果 X 可以放在该空穴而不破坏堆的序，那么插入完成
- 否则，我们把空穴的父节点上的元素移入该空穴中，这样，空穴就朝着根的方向上行一步
- 继续该过程直到 X 能被放入空穴中为止

##### DeleteMin(删除最小元) O(log N)
DeleteMin 以类似于插入的方式处理，不过使用的是 **下滤**

*下滤*：
- 当删除一个最小元时，在根节点处产生了一个空穴
- 由于现在堆少了一个元素，因此堆中最后一个元素 X 必须移动到该堆的某个地方
- 如果 X 可以被放到空穴中，那么 DeleteMin 完成
- 如果不可以放入，则将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了一层，重复该步骤直到 X 可以被放入空穴中

