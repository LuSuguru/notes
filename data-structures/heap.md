### 优先队列（堆）

优先队列是允许至少下列两种操作的数据结构：
- Insert：插入，等价于 Enqueue(入队)
- DeleteMin：找出、返回和删除优先队列中最小的元素，等价于出队(Dequeue)

### 优先队列几种简单的实现
##### 使用链表（有两种）
1. 在表头以 O(1) 执行插入操作，并遍历该链表以删除最小元，这需要 O(N) 时间
2. 始终让表保持排序状态，这使得插入代价高昂（O(N)）而 DeleteMin 花费低廉 (O(1))

##### 使用二叉查找树
它对两种操作的平均运行时间都是 O(log N)
基于 **二叉查找树** 的特性，插入是随机的，但删除则不是，会反复除去左子树中的节点

### 二叉堆（堆）
一般把二叉堆称为堆，它有两个性质，即结构性和堆序性

##### 结构性
堆是一棵被完全填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填入。这样的树称为 **完全二叉树**，它的高是 [Log N]

我们可以使用 **数组** 实现 **完全二叉树**

**对于数组中任一位置 i 上的元素，其左儿子在位置 2i 上，右儿子在左二子后的单元 (2i + 1)中，它的父亲则在位置 [i / 2]上**

##### 堆序性
使操作被快速执行的性质是 **堆序性**

- 由于我们需要快速地找出最小元，因此最小元应该在根上
- 如果我们考虑任意子树也应该是一个堆，那么任意节点就应该小于它的所有后裔

根据堆序性，最小元总可以在根处找到

### 堆的基本操作
##### Insert(插入) O(log N)

新元素插入时通过**上滤**找出正确的位置

*上滤*：
- 为将一个元素 X 插入到堆中，我们在下一个空闲位置创建一个空穴
- 如果 X 可以放在该空穴而不破坏堆的序，那么插入完成
- 否则，我们把空穴的父节点上的元素移入该空穴中，这样，空穴就朝着根的方向上行一步
- 继续该过程直到 X 能被放入空穴中为止

##### DeleteMin(删除最小元) O(log N)

DeleteMin 以类似于插入的方式处理，不过使用的是 **下滤**

*下滤*：
- 当删除一个最小元时，在根节点处产生了一个空穴
- 由于现在堆少了一个元素，因此堆中最后一个元素 X 必须移动到该堆的某个地方
- 如果 X 可以被放到空穴中，那么 DeleteMin 完成
- 如果不可以放入，则将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了一层，重复该步骤直到 X 可以被放入空穴中

##### DecreaseKey(降低关键字的值)

DecreaseKey(P,∆H) 降低在位置 P 处的关键字的值，降值的幅度为正的量 ∆
- 由于可能破坏堆的序，因此必须通过上滤对堆进行调整

##### IncreaseKey(增加关键字的值)

IncreaseKey(P,∆H) 增加位置 P 处的关键字的值，增加的幅度为正的量 ∆
- 同 DecreaseKey，需要通过下滤对堆进行调整

*案例：在操作系统对系统程序进行管理，通过 `DecreaseKey` 和 `IncreaseKey` 降低或者增加关键字的优先级*

##### Delete(删除)
Delete(P,H) 操作通过删除堆中位置P的节点，它分为两步，DecreaseKey => DeleteMin

*案例：当一个进程被用户中止时，它必须从优先队列中除去*

##### BuildHeap(构建堆)
- BuildHeap(H)把  N 个关键字作为输入并把它们放入空堆中。显然，这可以使用 N 个相继的 Insert(插入)操作来完成，由于每个 Insert 将花费 O(1) 平均时间，所以总的运行时间为 O(N)
- 当执行完 Insert 后，已经保证了树的结构性，为了堆序性，我们通过 percolateDown(i) 遍历对节点进行下钻，最终创建一个堆

```c
  for(i = N/2; i>0; i--) {
    percolateDown(i)
  }
```