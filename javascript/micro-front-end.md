# 微前端的调研和思考

|方式|实现|优点|缺点|
|-|-|-|-|
|MPA（当前使用）|1.每个应用内部引入相同的头部、菜单npm包<br>2.把界面、导航做成相同样子，让用户感觉是同一个应用|1.框架无关<br>2.独立开发、部署、运行<br>3.应用100%隔离<br>4.实现简单|1.体验差，切不同应用时有白屏，每个独立的SPA应用加载时间长|
|iframe(达芬奇的页面迁入等)|1.父页面通过iframe引入子页面|1.框架无关<br>2.独立开发、部署、运行<br>3.应用100%隔离<br>4.实现简单|1.慢，每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程<br>2.全局上下文完全隔离，内存变量不共享,iframe 内外系统的通信、数据同步等<br>3.DOM结构不共享，一些全局的UI很难搞，比如弹窗<br>4.url不同步，浏览器后退、前进|
|传统SPA+组件化NPM引入|1.业务写成NPM包的形式<br>2.需要该业务的父应用引入该NPM包|1.复用方便<br>2.渐进增强，逐步改进<br>|1.随着业务的增长，组件的粒度通信，组件的维护成本都在极具上升<br>2.不能做到真正的独立开发，测试，部署|
|通用基座式spa|1.整个应用分为主应用，子应用<br>2.主应用的代码一般非常简单，仅作为加载容器，管理子应用的生命周期<br>3.主应用捕获全局的路由事件，基于判断当前路由需要加载哪个子应用<br>4.子应用需要实现渲染，卸载的生命周期勾子，用于给主应用调用|1.框架无关<br>2.独立开发，部署，运行<br>3.项目自由切割，应用可以自由组合，方便复用|1.子应用需要实现生命钩子，第一次更换架构有侵入成本<br>2.由于存在各种全局污染（js,css）资源竞争，实现的难度较大，，考虑的东西也很多|
|特定基座式spa|1.整个应用同样分为主应用，子应用<br>2.主应用包括应用依赖的大多数环境，例如基础框架，基础组件与一些内部依赖包，对于我们就是（某个版本的react,antd,hop-request等），当我们的主应用启动之后，基本就有了全套的运行时环境<br>3.子应用只包含业务代码以及非基础的包<br>4.主应用捕获全局的路由事件，基于判断当前路由需要加载哪个子应用，然后load它|1.打包出来的子应用只包含了业务代码，体积小，加载快，用户体验好<br>2.第一次更换架构对子应用无侵入成本，只需要在webpack中将基础包剥离|1.主应用的架构决定了它是框架强相关，且锁死了框架版本，组件版本等，很不灵活，如果要升级基础模块，任何子应用都会有风险，都需要回归一遍，成本是巨大的<br>2.需要一整套开发体系来支撑，来解决公共资源的问题，从本地开发到打包到部署|

### 通用基座式spa 与 特定基座式spa 的区别
它们的区别有两点：
1. 路由的控制不同
2. 对技术栈的限制

#### 路由的控制：
- 在 **通用基座式** 中，子应用加载后，会由子应用去接管整个系统路由，卸载时，会再由主应用去接管
- 在 **特定基座式** 中，当子应用加载后，会把整个子应用的路由注入到主应用中，相当于 react-router 的异步加载，子应用并不接管整个系统路由，更像是主应用的一个“路由页面”

#### 技术栈的限制：
- **通用基座式**的主应用只负责加载容器，不包含任何与子应用耦合的模块，完全分离，子应用可以使用任意技术栈
- **特定基座式**的主应用包含了基础框架，基础模块，子应用必须服从，整个应用对技术方案的选择是限制死的

### 实现难度：
通用基座式 > 特定基座式



